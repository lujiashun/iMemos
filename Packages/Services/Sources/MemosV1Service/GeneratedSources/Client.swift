// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// ListActivities returns a list of activities.
    ///
    /// - Remark: HTTP `GET /api/v1/activities`.
    /// - Remark: Generated from `#/paths//api/v1/activities/get(ActivityService_ListActivities)`.
    public func ActivityService_ListActivities(_ input: Operations.ActivityService_ListActivities.Input) async throws -> Operations.ActivityService_ListActivities.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ActivityService_ListActivities.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/activities",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ActivityService_ListActivities.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListActivitiesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ActivityService_ListActivities.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetActivity returns the activity with the given id.
    ///
    /// - Remark: HTTP `GET /api/v1/activities/{activity}`.
    /// - Remark: Generated from `#/paths//api/v1/activities/{activity}/get(ActivityService_GetActivity)`.
    public func ActivityService_GetActivity(_ input: Operations.ActivityService_GetActivity.Input) async throws -> Operations.ActivityService_GetActivity.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ActivityService_GetActivity.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/activities/{}",
                    parameters: [
                        input.path.activity
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ActivityService_GetActivity.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Activity.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ActivityService_GetActivity.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListAttachments lists all attachments.
    ///
    /// - Remark: HTTP `GET /api/v1/attachments`.
    /// - Remark: Generated from `#/paths//api/v1/attachments/get(AttachmentService_ListAttachments)`.
    public func AttachmentService_ListAttachments(_ input: Operations.AttachmentService_ListAttachments.Input) async throws -> Operations.AttachmentService_ListAttachments.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AttachmentService_ListAttachments.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/attachments",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filter",
                    value: input.query.filter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderBy",
                    value: input.query.orderBy
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_ListAttachments.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListAttachmentsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_ListAttachments.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateAttachment creates a new attachment.
    ///
    /// - Remark: HTTP `POST /api/v1/attachments`.
    /// - Remark: Generated from `#/paths//api/v1/attachments/post(AttachmentService_CreateAttachment)`.
    public func AttachmentService_CreateAttachment(_ input: Operations.AttachmentService_CreateAttachment.Input) async throws -> Operations.AttachmentService_CreateAttachment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AttachmentService_CreateAttachment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/attachments",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "attachmentId",
                    value: input.query.attachmentId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_CreateAttachment.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Attachment.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_CreateAttachment.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetAttachment returns a attachment by name.
    ///
    /// - Remark: HTTP `GET /api/v1/attachments/{attachment}`.
    /// - Remark: Generated from `#/paths//api/v1/attachments/{attachment}/get(AttachmentService_GetAttachment)`.
    public func AttachmentService_GetAttachment(_ input: Operations.AttachmentService_GetAttachment.Input) async throws -> Operations.AttachmentService_GetAttachment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AttachmentService_GetAttachment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/attachments/{}",
                    parameters: [
                        input.path.attachment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_GetAttachment.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Attachment.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_GetAttachment.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateAttachment updates a attachment.
    ///
    /// - Remark: HTTP `PATCH /api/v1/attachments/{attachment}`.
    /// - Remark: Generated from `#/paths//api/v1/attachments/{attachment}/patch(AttachmentService_UpdateAttachment)`.
    public func AttachmentService_UpdateAttachment(_ input: Operations.AttachmentService_UpdateAttachment.Input) async throws -> Operations.AttachmentService_UpdateAttachment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AttachmentService_UpdateAttachment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/attachments/{}",
                    parameters: [
                        input.path.attachment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_UpdateAttachment.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Attachment.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_UpdateAttachment.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteAttachment deletes a attachment by name.
    ///
    /// - Remark: HTTP `DELETE /api/v1/attachments/{attachment}`.
    /// - Remark: Generated from `#/paths//api/v1/attachments/{attachment}/delete(AttachmentService_DeleteAttachment)`.
    public func AttachmentService_DeleteAttachment(_ input: Operations.AttachmentService_DeleteAttachment.Input) async throws -> Operations.AttachmentService_DeleteAttachment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AttachmentService_DeleteAttachment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/attachments/{}",
                    parameters: [
                        input.path.attachment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AttachmentService_DeleteAttachment.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetCurrentUser returns the authenticated user's information.
    ///  Validates the access token and returns user details.
    ///  Similar to OIDC's /userinfo endpoint.
    ///
    /// - Remark: HTTP `GET /api/v1/auth/me`.
    /// - Remark: Generated from `#/paths//api/v1/auth/me/get(AuthService_GetCurrentUser)`.
    public func AuthService_GetCurrentUser(_ input: Operations.AuthService_GetCurrentUser.Input) async throws -> Operations.AuthService_GetCurrentUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthService_GetCurrentUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/auth/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_GetCurrentUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetCurrentUserResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_GetCurrentUser.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// RefreshToken exchanges a valid refresh token for a new access token.
    ///  The refresh token is read from the HttpOnly cookie.
    ///  Returns a new short-lived access token.
    ///
    /// - Remark: HTTP `POST /api/v1/auth/refresh`.
    /// - Remark: Generated from `#/paths//api/v1/auth/refresh/post(AuthService_RefreshToken)`.
    public func AuthService_RefreshToken(_ input: Operations.AuthService_RefreshToken.Input) async throws -> Operations.AuthService_RefreshToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthService_RefreshToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/auth/refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_RefreshToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RefreshTokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_RefreshToken.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// SignIn authenticates a user with credentials and returns tokens.
    ///  On success, returns an access token and sets a refresh token cookie.
    ///  Supports password-based and SSO authentication methods.
    ///
    /// - Remark: HTTP `POST /api/v1/auth/signin`.
    /// - Remark: Generated from `#/paths//api/v1/auth/signin/post(AuthService_SignIn)`.
    public func AuthService_SignIn(_ input: Operations.AuthService_SignIn.Input) async throws -> Operations.AuthService_SignIn.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthService_SignIn.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/auth/signin",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_SignIn.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SignInResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_SignIn.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// SignOut terminates the user's authentication.
    ///  Revokes the refresh token and clears the authentication cookie.
    ///
    /// - Remark: HTTP `POST /api/v1/auth/signout`.
    /// - Remark: Generated from `#/paths//api/v1/auth/signout/post(AuthService_SignOut)`.
    public func AuthService_SignOut(_ input: Operations.AuthService_SignOut.Input) async throws -> Operations.AuthService_SignOut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthService_SignOut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/auth/signout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthService_SignOut.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListIdentityProviders lists identity providers.
    ///
    /// - Remark: HTTP `GET /api/v1/identity-providers`.
    /// - Remark: Generated from `#/paths//api/v1/identity-providers/get(IdentityProviderService_ListIdentityProviders)`.
    public func IdentityProviderService_ListIdentityProviders(_ input: Operations.IdentityProviderService_ListIdentityProviders.Input) async throws -> Operations.IdentityProviderService_ListIdentityProviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.IdentityProviderService_ListIdentityProviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/identity-providers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_ListIdentityProviders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListIdentityProvidersResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_ListIdentityProviders.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateIdentityProvider creates an identity provider.
    ///
    /// - Remark: HTTP `POST /api/v1/identity-providers`.
    /// - Remark: Generated from `#/paths//api/v1/identity-providers/post(IdentityProviderService_CreateIdentityProvider)`.
    public func IdentityProviderService_CreateIdentityProvider(_ input: Operations.IdentityProviderService_CreateIdentityProvider.Input) async throws -> Operations.IdentityProviderService_CreateIdentityProvider.Output {
        try await client.send(
            input: input,
            forOperation: Operations.IdentityProviderService_CreateIdentityProvider.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/identity-providers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identityProviderId",
                    value: input.query.identityProviderId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_CreateIdentityProvider.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IdentityProvider.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_CreateIdentityProvider.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetIdentityProvider gets an identity provider.
    ///
    /// - Remark: HTTP `GET /api/v1/identity-providers/{identity-provider}`.
    /// - Remark: Generated from `#/paths//api/v1/identity-providers/{identity-provider}/get(IdentityProviderService_GetIdentityProvider)`.
    public func IdentityProviderService_GetIdentityProvider(_ input: Operations.IdentityProviderService_GetIdentityProvider.Input) async throws -> Operations.IdentityProviderService_GetIdentityProvider.Output {
        try await client.send(
            input: input,
            forOperation: Operations.IdentityProviderService_GetIdentityProvider.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/identity-providers/{}",
                    parameters: [
                        input.path.identity_hyphen_provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_GetIdentityProvider.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IdentityProvider.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_GetIdentityProvider.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateIdentityProvider updates an identity provider.
    ///
    /// - Remark: HTTP `PATCH /api/v1/identity-providers/{identity-provider}`.
    /// - Remark: Generated from `#/paths//api/v1/identity-providers/{identity-provider}/patch(IdentityProviderService_UpdateIdentityProvider)`.
    public func IdentityProviderService_UpdateIdentityProvider(_ input: Operations.IdentityProviderService_UpdateIdentityProvider.Input) async throws -> Operations.IdentityProviderService_UpdateIdentityProvider.Output {
        try await client.send(
            input: input,
            forOperation: Operations.IdentityProviderService_UpdateIdentityProvider.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/identity-providers/{}",
                    parameters: [
                        input.path.identity_hyphen_provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_UpdateIdentityProvider.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IdentityProvider.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_UpdateIdentityProvider.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteIdentityProvider deletes an identity provider.
    ///
    /// - Remark: HTTP `DELETE /api/v1/identity-providers/{identity-provider}`.
    /// - Remark: Generated from `#/paths//api/v1/identity-providers/{identity-provider}/delete(IdentityProviderService_DeleteIdentityProvider)`.
    public func IdentityProviderService_DeleteIdentityProvider(_ input: Operations.IdentityProviderService_DeleteIdentityProvider.Input) async throws -> Operations.IdentityProviderService_DeleteIdentityProvider.Output {
        try await client.send(
            input: input,
            forOperation: Operations.IdentityProviderService_DeleteIdentityProvider.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/identity-providers/{}",
                    parameters: [
                        input.path.identity_hyphen_provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.IdentityProviderService_DeleteIdentityProvider.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// Gets the instance profile.
    ///
    /// - Remark: HTTP `GET /api/v1/instance/profile`.
    /// - Remark: Generated from `#/paths//api/v1/instance/profile/get(InstanceService_GetInstanceProfile)`.
    public func InstanceService_GetInstanceProfile(_ input: Operations.InstanceService_GetInstanceProfile.Input) async throws -> Operations.InstanceService_GetInstanceProfile.Output {
        try await client.send(
            input: input,
            forOperation: Operations.InstanceService_GetInstanceProfile.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/instance/profile",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_GetInstanceProfile.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InstanceProfile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_GetInstanceProfile.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// Gets an instance setting.
    ///
    /// - Remark: HTTP `GET /api/v1/instance/{instance}/*`.
    /// - Remark: Generated from `#/paths//api/v1/instance/{instance}/*/get(InstanceService_GetInstanceSetting)`.
    public func InstanceService_GetInstanceSetting(_ input: Operations.InstanceService_GetInstanceSetting.Input) async throws -> Operations.InstanceService_GetInstanceSetting.Output {
        try await client.send(
            input: input,
            forOperation: Operations.InstanceService_GetInstanceSetting.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/instance/{}/*",
                    parameters: [
                        input.path.instance
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_GetInstanceSetting.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InstanceSetting.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_GetInstanceSetting.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// Updates an instance setting.
    ///
    /// - Remark: HTTP `PATCH /api/v1/instance/{instance}/*`.
    /// - Remark: Generated from `#/paths//api/v1/instance/{instance}/*/patch(InstanceService_UpdateInstanceSetting)`.
    public func InstanceService_UpdateInstanceSetting(_ input: Operations.InstanceService_UpdateInstanceSetting.Input) async throws -> Operations.InstanceService_UpdateInstanceSetting.Output {
        try await client.send(
            input: input,
            forOperation: Operations.InstanceService_UpdateInstanceSetting.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/instance/{}/*",
                    parameters: [
                        input.path.instance
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_UpdateInstanceSetting.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InstanceSetting.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.InstanceService_UpdateInstanceSetting.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListMemos lists memos with pagination and filter.
    ///
    /// - Remark: HTTP `GET /api/v1/memos`.
    /// - Remark: Generated from `#/paths//api/v1/memos/get(MemoService_ListMemos)`.
    public func MemoService_ListMemos(_ input: Operations.MemoService_ListMemos.Input) async throws -> Operations.MemoService_ListMemos.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_ListMemos.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderBy",
                    value: input.query.orderBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filter",
                    value: input.query.filter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "showDeleted",
                    value: input.query.showDeleted
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemos.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListMemosResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemos.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateMemo creates a memo.
    ///
    /// - Remark: HTTP `POST /api/v1/memos`.
    /// - Remark: Generated from `#/paths//api/v1/memos/post(MemoService_CreateMemo)`.
    public func MemoService_CreateMemo(_ input: Operations.MemoService_CreateMemo.Input) async throws -> Operations.MemoService_CreateMemo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_CreateMemo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "memoId",
                    value: input.query.memoId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_CreateMemo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Memo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_CreateMemo.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetMemo gets a memo.
    ///
    /// - Remark: HTTP `GET /api/v1/memos/{memo}`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/get(MemoService_GetMemo)`.
    public func MemoService_GetMemo(_ input: Operations.MemoService_GetMemo.Input) async throws -> Operations.MemoService_GetMemo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_GetMemo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetMemo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Memo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetMemo.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateMemo updates a memo.
    ///
    /// - Remark: HTTP `PATCH /api/v1/memos/{memo}`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/patch(MemoService_UpdateMemo)`.
    public func MemoService_UpdateMemo(_ input: Operations.MemoService_UpdateMemo.Input) async throws -> Operations.MemoService_UpdateMemo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_UpdateMemo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_UpdateMemo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Memo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_UpdateMemo.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteMemo deletes a memo.
    ///
    /// - Remark: HTTP `DELETE /api/v1/memos/{memo}`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/delete(MemoService_DeleteMemo)`.
    public func MemoService_DeleteMemo(_ input: Operations.MemoService_DeleteMemo.Input) async throws -> Operations.MemoService_DeleteMemo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_DeleteMemo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "force",
                    value: input.query.force
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_DeleteMemo.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListMemoAttachments lists attachments for a memo.
    ///
    /// - Remark: HTTP `GET /api/v1/memos/{memo}/attachments`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/attachments/get(MemoService_ListMemoAttachments)`.
    public func MemoService_ListMemoAttachments(_ input: Operations.MemoService_ListMemoAttachments.Input) async throws -> Operations.MemoService_ListMemoAttachments.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_ListMemoAttachments.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/attachments",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoAttachments.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListMemoAttachmentsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoAttachments.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// SetMemoAttachments sets attachments for a memo.
    ///
    /// - Remark: HTTP `PATCH /api/v1/memos/{memo}/attachments`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/attachments/patch(MemoService_SetMemoAttachments)`.
    public func MemoService_SetMemoAttachments(_ input: Operations.MemoService_SetMemoAttachments.Input) async throws -> Operations.MemoService_SetMemoAttachments.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_SetMemoAttachments.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/attachments",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_SetMemoAttachments.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListMemoComments lists comments for a memo.
    ///
    /// - Remark: HTTP `GET /api/v1/memos/{memo}/comments`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/comments/get(MemoService_ListMemoComments)`.
    public func MemoService_ListMemoComments(_ input: Operations.MemoService_ListMemoComments.Input) async throws -> Operations.MemoService_ListMemoComments.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_ListMemoComments.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/comments",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderBy",
                    value: input.query.orderBy
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoComments.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListMemoCommentsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoComments.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateMemoComment creates a comment for a memo.
    ///
    /// - Remark: HTTP `POST /api/v1/memos/{memo}/comments`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/comments/post(MemoService_CreateMemoComment)`.
    public func MemoService_CreateMemoComment(_ input: Operations.MemoService_CreateMemoComment.Input) async throws -> Operations.MemoService_CreateMemoComment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_CreateMemoComment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/comments",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "commentId",
                    value: input.query.commentId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_CreateMemoComment.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Memo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_CreateMemoComment.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListMemoReactions lists reactions for a memo.
    ///
    /// - Remark: HTTP `GET /api/v1/memos/{memo}/reactions`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/reactions/get(MemoService_ListMemoReactions)`.
    public func MemoService_ListMemoReactions(_ input: Operations.MemoService_ListMemoReactions.Input) async throws -> Operations.MemoService_ListMemoReactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_ListMemoReactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/reactions",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoReactions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListMemoReactionsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoReactions.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpsertMemoReaction upserts a reaction for a memo.
    ///
    /// - Remark: HTTP `POST /api/v1/memos/{memo}/reactions`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/reactions/post(MemoService_UpsertMemoReaction)`.
    public func MemoService_UpsertMemoReaction(_ input: Operations.MemoService_UpsertMemoReaction.Input) async throws -> Operations.MemoService_UpsertMemoReaction.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_UpsertMemoReaction.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/reactions",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_UpsertMemoReaction.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Reaction.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_UpsertMemoReaction.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteMemoReaction deletes a reaction for a memo.
    ///
    /// - Remark: HTTP `DELETE /api/v1/memos/{memo}/reactions/{reaction}`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/reactions/{reaction}/delete(MemoService_DeleteMemoReaction)`.
    public func MemoService_DeleteMemoReaction(_ input: Operations.MemoService_DeleteMemoReaction.Input) async throws -> Operations.MemoService_DeleteMemoReaction.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_DeleteMemoReaction.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/reactions/{}",
                    parameters: [
                        input.path.memo,
                        input.path.reaction
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_DeleteMemoReaction.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListMemoRelations lists relations for a memo.
    ///
    /// - Remark: HTTP `GET /api/v1/memos/{memo}/relations`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/relations/get(MemoService_ListMemoRelations)`.
    public func MemoService_ListMemoRelations(_ input: Operations.MemoService_ListMemoRelations.Input) async throws -> Operations.MemoService_ListMemoRelations.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_ListMemoRelations.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/relations",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoRelations.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListMemoRelationsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_ListMemoRelations.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// SetMemoRelations sets relations for a memo.
    ///
    /// - Remark: HTTP `PATCH /api/v1/memos/{memo}/relations`.
    /// - Remark: Generated from `#/paths//api/v1/memos/{memo}/relations/patch(MemoService_SetMemoRelations)`.
    public func MemoService_SetMemoRelations(_ input: Operations.MemoService_SetMemoRelations.Input) async throws -> Operations.MemoService_SetMemoRelations.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_SetMemoRelations.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos/{}/relations",
                    parameters: [
                        input.path.memo
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_SetMemoRelations.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetDailyReview generates a daily review for the requested date.
    ///
    /// - Remark: HTTP `POST /api/v1/memos:daily_review`.
    /// - Remark: Generated from `#/paths//api/v1/memos:daily_review/post(MemoService_GetDailyReview)`.
    public func MemoService_GetDailyReview(_ input: Operations.MemoService_GetDailyReview.Input) async throws -> Operations.MemoService_GetDailyReview.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_GetDailyReview.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos:daily_review",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetDailyReview.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetDailyReviewResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetDailyReview.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetMemoInsight generates a insight for the requested memos.
    ///
    /// - Remark: HTTP `POST /api/v1/memos:insight`.
    /// - Remark: Generated from `#/paths//api/v1/memos:insight/post(MemoService_GetMemoInsight)`.
    public func MemoService_GetMemoInsight(_ input: Operations.MemoService_GetMemoInsight.Input) async throws -> Operations.MemoService_GetMemoInsight.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_GetMemoInsight.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/memos:insight",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetMemoInsight.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetMemoInsightResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_GetMemoInsight.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// TextRefine refines input text with a prompt.
    ///
    /// - Remark: HTTP `POST /api/v1/text_refine`.
    /// - Remark: Generated from `#/paths//api/v1/text_refine/post(MemoService_TextRefine)`.
    public func MemoService_TextRefine(_ input: Operations.MemoService_TextRefine.Input) async throws -> Operations.MemoService_TextRefine.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MemoService_TextRefine.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/text_refine",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_TextRefine.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TextRefineResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MemoService_TextRefine.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListUsers returns a list of users.
    ///
    /// - Remark: HTTP `GET /api/v1/users`.
    /// - Remark: Generated from `#/paths//api/v1/users/get(UserService_ListUsers)`.
    public func UserService_ListUsers(_ input: Operations.UserService_ListUsers.Input) async throws -> Operations.UserService_ListUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filter",
                    value: input.query.filter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "showDeleted",
                    value: input.query.showDeleted
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUsers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListUsersResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUsers.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateUser creates a new user.
    ///
    /// - Remark: HTTP `POST /api/v1/users`.
    /// - Remark: Generated from `#/paths//api/v1/users/post(UserService_CreateUser)`.
    public func UserService_CreateUser(_ input: Operations.UserService_CreateUser.Input) async throws -> Operations.UserService_CreateUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_CreateUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "validateOnly",
                    value: input.query.validateOnly
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "requestId",
                    value: input.query.requestId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreateUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.User.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreateUser.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetUser gets a user by ID or username.
    ///  Supports both numeric IDs and username strings:
    ///    - users/{id}       (e.g., users/101)
    ///    - users/{username} (e.g., users/steven)
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/get(UserService_GetUser)`.
    public func UserService_GetUser(_ input: Operations.UserService_GetUser.Input) async throws -> Operations.UserService_GetUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_GetUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "readMask",
                    value: input.query.readMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.User.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUser.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateUser updates a user.
    ///
    /// - Remark: HTTP `PATCH /api/v1/users/{user}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/patch(UserService_UpdateUser)`.
    public func UserService_UpdateUser(_ input: Operations.UserService_UpdateUser.Input) async throws -> Operations.UserService_UpdateUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_UpdateUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "allowMissing",
                    value: input.query.allowMissing
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.User.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUser.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteUser deletes a user.
    ///
    /// - Remark: HTTP `DELETE /api/v1/users/{user}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/delete(UserService_DeleteUser)`.
    public func UserService_DeleteUser(_ input: Operations.UserService_DeleteUser.Input) async throws -> Operations.UserService_DeleteUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_DeleteUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "force",
                    value: input.query.force
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_DeleteUser.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListUserNotifications lists notifications for a user.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/notifications`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/notifications/get(UserService_ListUserNotifications)`.
    public func UserService_ListUserNotifications(_ input: Operations.UserService_ListUserNotifications.Input) async throws -> Operations.UserService_ListUserNotifications.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListUserNotifications.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/notifications",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filter",
                    value: input.query.filter
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserNotifications.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListUserNotificationsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserNotifications.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateUserNotification updates a notification.
    ///
    /// - Remark: HTTP `PATCH /api/v1/users/{user}/notifications/{notification}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/notifications/{notification}/patch(UserService_UpdateUserNotification)`.
    public func UserService_UpdateUserNotification(_ input: Operations.UserService_UpdateUserNotification.Input) async throws -> Operations.UserService_UpdateUserNotification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_UpdateUserNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/notifications/{}",
                    parameters: [
                        input.path.user,
                        input.path.notification
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserNotification.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserNotification.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserNotification.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteUserNotification deletes a notification.
    ///
    /// - Remark: HTTP `DELETE /api/v1/users/{user}/notifications/{notification}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/notifications/{notification}/delete(UserService_DeleteUserNotification)`.
    public func UserService_DeleteUserNotification(_ input: Operations.UserService_DeleteUserNotification.Input) async throws -> Operations.UserService_DeleteUserNotification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_DeleteUserNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/notifications/{}",
                    parameters: [
                        input.path.user,
                        input.path.notification
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_DeleteUserNotification.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListPersonalAccessTokens returns a list of Personal Access Tokens (PATs) for a user.
    ///  PATs are long-lived tokens for API/script access, distinct from short-lived JWT access tokens.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/personalAccessTokens`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/personalAccessTokens/get(UserService_ListPersonalAccessTokens)`.
    public func UserService_ListPersonalAccessTokens(_ input: Operations.UserService_ListPersonalAccessTokens.Input) async throws -> Operations.UserService_ListPersonalAccessTokens.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListPersonalAccessTokens.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/personalAccessTokens",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListPersonalAccessTokens.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListPersonalAccessTokensResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListPersonalAccessTokens.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreatePersonalAccessToken creates a new Personal Access Token for a user.
    ///  The token value is only returned once upon creation.
    ///
    /// - Remark: HTTP `POST /api/v1/users/{user}/personalAccessTokens`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/personalAccessTokens/post(UserService_CreatePersonalAccessToken)`.
    public func UserService_CreatePersonalAccessToken(_ input: Operations.UserService_CreatePersonalAccessToken.Input) async throws -> Operations.UserService_CreatePersonalAccessToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_CreatePersonalAccessToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/personalAccessTokens",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreatePersonalAccessToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CreatePersonalAccessTokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreatePersonalAccessToken.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeletePersonalAccessToken deletes a Personal Access Token.
    ///
    /// - Remark: HTTP `DELETE /api/v1/users/{user}/personalAccessTokens/{personalAccessToken}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/personalAccessTokens/{personalAccessToken}/delete(UserService_DeletePersonalAccessToken)`.
    public func UserService_DeletePersonalAccessToken(_ input: Operations.UserService_DeletePersonalAccessToken.Input) async throws -> Operations.UserService_DeletePersonalAccessToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_DeletePersonalAccessToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/personalAccessTokens/{}",
                    parameters: [
                        input.path.user,
                        input.path.personalAccessToken
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_DeletePersonalAccessToken.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListUserSettings returns a list of user settings.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/settings`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/settings/get(UserService_ListUserSettings)`.
    public func UserService_ListUserSettings(_ input: Operations.UserService_ListUserSettings.Input) async throws -> Operations.UserService_ListUserSettings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListUserSettings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/settings",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageSize",
                    value: input.query.pageSize
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageToken",
                    value: input.query.pageToken
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserSettings.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListUserSettingsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserSettings.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetUserSetting returns the user setting.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/settings/{setting}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/settings/{setting}/get(UserService_GetUserSetting)`.
    public func UserService_GetUserSetting(_ input: Operations.UserService_GetUserSetting.Input) async throws -> Operations.UserService_GetUserSetting.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_GetUserSetting.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/settings/{}",
                    parameters: [
                        input.path.user,
                        input.path.setting
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUserSetting.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserSetting.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUserSetting.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateUserSetting updates the user setting.
    ///
    /// - Remark: HTTP `PATCH /api/v1/users/{user}/settings/{setting}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/settings/{setting}/patch(UserService_UpdateUserSetting)`.
    public func UserService_UpdateUserSetting(_ input: Operations.UserService_UpdateUserSetting.Input) async throws -> Operations.UserService_UpdateUserSetting.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_UpdateUserSetting.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/settings/{}",
                    parameters: [
                        input.path.user,
                        input.path.setting
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserSetting.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserSetting.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserSetting.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListShortcuts returns a list of shortcuts for a user.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/shortcuts`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/shortcuts/get(ShortcutService_ListShortcuts)`.
    public func ShortcutService_ListShortcuts(_ input: Operations.ShortcutService_ListShortcuts.Input) async throws -> Operations.ShortcutService_ListShortcuts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ShortcutService_ListShortcuts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/shortcuts",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_ListShortcuts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListShortcutsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_ListShortcuts.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateShortcut creates a new shortcut for a user.
    ///
    /// - Remark: HTTP `POST /api/v1/users/{user}/shortcuts`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/shortcuts/post(ShortcutService_CreateShortcut)`.
    public func ShortcutService_CreateShortcut(_ input: Operations.ShortcutService_CreateShortcut.Input) async throws -> Operations.ShortcutService_CreateShortcut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ShortcutService_CreateShortcut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/shortcuts",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "validateOnly",
                    value: input.query.validateOnly
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_CreateShortcut.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Shortcut.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_CreateShortcut.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetShortcut gets a shortcut by name.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/shortcuts/{shortcut}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/shortcuts/{shortcut}/get(ShortcutService_GetShortcut)`.
    public func ShortcutService_GetShortcut(_ input: Operations.ShortcutService_GetShortcut.Input) async throws -> Operations.ShortcutService_GetShortcut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ShortcutService_GetShortcut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/shortcuts/{}",
                    parameters: [
                        input.path.user,
                        input.path.shortcut
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_GetShortcut.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Shortcut.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_GetShortcut.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateShortcut updates a shortcut for a user.
    ///
    /// - Remark: HTTP `PATCH /api/v1/users/{user}/shortcuts/{shortcut}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/shortcuts/{shortcut}/patch(ShortcutService_UpdateShortcut)`.
    public func ShortcutService_UpdateShortcut(_ input: Operations.ShortcutService_UpdateShortcut.Input) async throws -> Operations.ShortcutService_UpdateShortcut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ShortcutService_UpdateShortcut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/shortcuts/{}",
                    parameters: [
                        input.path.user,
                        input.path.shortcut
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_UpdateShortcut.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Shortcut.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_UpdateShortcut.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteShortcut deletes a shortcut for a user.
    ///
    /// - Remark: HTTP `DELETE /api/v1/users/{user}/shortcuts/{shortcut}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/shortcuts/{shortcut}/delete(ShortcutService_DeleteShortcut)`.
    public func ShortcutService_DeleteShortcut(_ input: Operations.ShortcutService_DeleteShortcut.Input) async throws -> Operations.ShortcutService_DeleteShortcut.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ShortcutService_DeleteShortcut.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/shortcuts/{}",
                    parameters: [
                        input.path.user,
                        input.path.shortcut
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ShortcutService_DeleteShortcut.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListUserWebhooks returns a list of webhooks for a user.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}/webhooks`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/webhooks/get(UserService_ListUserWebhooks)`.
    public func UserService_ListUserWebhooks(_ input: Operations.UserService_ListUserWebhooks.Input) async throws -> Operations.UserService_ListUserWebhooks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListUserWebhooks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/webhooks",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserWebhooks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListUserWebhooksResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListUserWebhooks.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// CreateUserWebhook creates a new webhook for a user.
    ///
    /// - Remark: HTTP `POST /api/v1/users/{user}/webhooks`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/webhooks/post(UserService_CreateUserWebhook)`.
    public func UserService_CreateUserWebhook(_ input: Operations.UserService_CreateUserWebhook.Input) async throws -> Operations.UserService_CreateUserWebhook.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_CreateUserWebhook.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/webhooks",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreateUserWebhook.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserWebhook.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_CreateUserWebhook.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// UpdateUserWebhook updates an existing webhook for a user.
    ///
    /// - Remark: HTTP `PATCH /api/v1/users/{user}/webhooks/{webhook}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/webhooks/{webhook}/patch(UserService_UpdateUserWebhook)`.
    public func UserService_UpdateUserWebhook(_ input: Operations.UserService_UpdateUserWebhook.Input) async throws -> Operations.UserService_UpdateUserWebhook.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_UpdateUserWebhook.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/webhooks/{}",
                    parameters: [
                        input.path.user,
                        input.path.webhook
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "updateMask",
                    value: input.query.updateMask
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserWebhook.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserWebhook.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_UpdateUserWebhook.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// DeleteUserWebhook deletes a webhook for a user.
    ///
    /// - Remark: HTTP `DELETE /api/v1/users/{user}/webhooks/{webhook}`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}/webhooks/{webhook}/delete(UserService_DeleteUserWebhook)`.
    public func UserService_DeleteUserWebhook(_ input: Operations.UserService_DeleteUserWebhook.Input) async throws -> Operations.UserService_DeleteUserWebhook.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_DeleteUserWebhook.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}/webhooks/{}",
                    parameters: [
                        input.path.user,
                        input.path.webhook
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_DeleteUserWebhook.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// GetUserStats returns statistics for a specific user.
    ///
    /// - Remark: HTTP `GET /api/v1/users/{user}:getStats`.
    /// - Remark: Generated from `#/paths//api/v1/users/{user}:getStats/get(UserService_GetUserStats)`.
    public func UserService_GetUserStats(_ input: Operations.UserService_GetUserStats.Input) async throws -> Operations.UserService_GetUserStats.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_GetUserStats.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users/{}:getStats",
                    parameters: [
                        input.path.user
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUserStats.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserStats.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_GetUserStats.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
    /// ListAllUserStats returns statistics for all users.
    ///
    /// - Remark: HTTP `GET /api/v1/users:stats`.
    /// - Remark: Generated from `#/paths//api/v1/users:stats/get(UserService_ListAllUserStats)`.
    public func UserService_ListAllUserStats(_ input: Operations.UserService_ListAllUserStats.Input) async throws -> Operations.UserService_ListAllUserStats.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UserService_ListAllUserStats.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v1/users:stats",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListAllUserStats.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ListAllUserStatsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UserService_ListAllUserStats.Output.Default.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .`default`(
                        statusCode: response.status.code,
                        .init(body: body)
                    )
                }
            }
        )
    }
}
